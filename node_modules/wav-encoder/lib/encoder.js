"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

"use stirct";

var InlineWorker = _interopRequire(require("inline-worker"));

var encoder = _interopRequire(require("./encoder-worker"));

var Encoder = (function () {
  function Encoder() {
    var _this = this;

    var format = arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Encoder);

    this.format = {
      floatingPoint: !!format.floatingPoint,
      bitDepth: format.bitDepth | 0 || 16 };
    this._worker = new InlineWorker(encoder, encoder.self);
    this._worker.onmessage = function (e) {
      var callback = _this._callbacks[e.data.callbackId];

      if (callback) {
        if (e.data.type === "encoded") {
          callback.resolve(e.data.buffer);
        } else {
          callback.reject(new Error(e.data.message));
        }
      }

      _this._callbacks[e.data.callbackId] = null;
    };
    this._callbacks = [];
  }

  _createClass(Encoder, {
    canProcess: {
      value: function canProcess(format) {
        return Encoder.canProcess(format);
      }
    },
    encode: {
      value: function encode(audioData, format) {
        var _this = this;

        if (format == null || typeof format !== "object") {
          format = this.format;
        }
        return new Promise(function (resolve, reject) {
          var callbackId = _this._callbacks.length;

          _this._callbacks.push({ resolve: resolve, reject: reject });

          var numberOfChannels = audioData.channelData.length;
          var length = audioData.channelData[0].length;
          var sampleRate = audioData.sampleRate;
          var buffers = audioData.channelData.map(function (data) {
            return data.buffer;
          });

          audioData = { numberOfChannels: numberOfChannels, length: length, sampleRate: sampleRate, buffers: buffers };

          _this._worker.postMessage({
            type: "encode", audioData: audioData, format: format, callbackId: callbackId
          }, audioData.buffers);
        });
      }
    }
  }, {
    canProcess: {
      value: function canProcess(format) {
        if (format && (format === "wav" || format.type === "wav")) {
          return "maybe";
        }
        return "";
      }
    },
    encode: {
      value: function encode(audioData, format) {
        return new Encoder(format).encode(audioData);
      }
    }
  });

  return Encoder;
})();

module.exports = Encoder;